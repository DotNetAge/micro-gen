package projection

import (
	"context"
	"{{project_path}}/internal/entity"
)

// Store 投影存储接口
type Store interface {
	// Save 保存单个投影
	Save(ctx context.Context, projection entity.Projection) error
	
	// SaveBatch 批量保存投影
	SaveBatch(ctx context.Context, projections []entity.Projection) error
	
	// GetByID 根据ID获取投影
	GetByID(ctx context.Context, id string, projectionType string) (entity.Projection, error)
	
	// Query 根据条件查询投影
	Query(ctx context.Context, query *Query) ([]entity.Projection, error)
	
	// Delete 删除投影
	Delete(ctx context.Context, id string, projectionType string) error
	
	// GetVersion 获取投影版本号
	GetVersion(ctx context.Context, aggregateID string, projectionType string) (int64, error)
	
	// UpdateVersion 更新投影版本号
	UpdateVersion(ctx context.Context, aggregateID string, projectionType string, version int64) error
}

// Query 查询条件
type Query struct {
	// ProjectionType 投影类型
	ProjectionType string
	
	// Filters 过滤条件
	Filters map[string]interface{}
	
	// SortBy 排序字段
	SortBy string
	
	// SortOrder 排序顺序（ASC/DESC）
	SortOrder string
	
	// Limit 限制返回数量
	Limit int
	
	// Offset 偏移量
	Offset int
}

// MemoryStore 内存存储实现

type MemoryStore struct {
	data    map[string]entity.Projection
	version map[string]int64
}

// NewMemoryStore 创建内存存储
func NewMemoryStore() *MemoryStore {
	return &MemoryStore{
		data:    make(map[string]entity.Projection),
		version: make(map[string]int64),
	}
}

// Save 保存单个投影
func (s *MemoryStore) Save(ctx context.Context, projection entity.Projection) error {
	key := s.buildKey(projection.GetID(), projection.GetProjectionType())
	s.data[key] = projection
	s.version[key] = projection.GetVersion()
	return nil
}

// SaveBatch 批量保存投影
func (s *MemoryStore) SaveBatch(ctx context.Context, projections []entity.Projection) error {
	for _, p := range projections {
		if err := s.Save(ctx, p); err != nil {
			return err
		}
	}
	return nil
}

// GetByID 根据ID获取投影
func (s *MemoryStore) GetByID(ctx context.Context, id string, projectionType string) (entity.Projection, error) {
	key := s.buildKey(id, projectionType)
	projection, exists := s.data[key]
	if !exists {
		return nil, ErrNotFound
	}
	return projection, nil
}

// Query 根据条件查询投影
func (s *MemoryStore) Query(ctx context.Context, query *Query) ([]entity.Projection, error) {
	var results []entity.Projection
	
	for _, projection := range s.data {
		if query.ProjectionType != "" && projection.GetProjectionType() != query.ProjectionType {
			continue
		}
		
		// 简单的过滤逻辑
		match := true
		for key, value := range query.Filters {
			if projection.GetData()[key] != value {
				match = false
				break
			}
		}
		
		if match {
			results = append(results, projection)
		}
	}
	
	// 简单的分页
	if query.Offset > len(results) {
		return []entity.Projection{}, nil
	}
	
	end := query.Offset + query.Limit
	if query.Limit <= 0 || end > len(results) {
		end = len(results)
	}
	
	return results[query.Offset:end], nil
}

// Delete 删除投影
func (s *MemoryStore) Delete(ctx context.Context, id string, projectionType string) error {
	key := s.buildKey(id, projectionType)
	delete(s.data, key)
	delete(s.version, key)
	return nil
}

// GetVersion 获取投影版本号
func (s *MemoryStore) GetVersion(ctx context.Context, aggregateID string, projectionType string) (int64, error) {
	key := s.buildKey(aggregateID, projectionType)
	version, exists := s.version[key]
	if !exists {
		return 0, nil
	}
	return version, nil
}

// UpdateVersion 更新投影版本号
func (s *MemoryStore) UpdateVersion(ctx context.Context, aggregateID string, projectionType string, version int64) error {
	key := s.buildKey(aggregateID, projectionType)
	s.version[key] = version
	return nil
}

// buildKey 构建存储键
func (s *MemoryStore) buildKey(id string, projectionType string) string {
	return projectionType + ":" + id
}

// ErrNotFound 投影未找到错误
var ErrNotFound = &NotFoundError{}

// NotFoundError 未找到错误类型
type NotFoundError struct{}

func (e *NotFoundError) Error() string {
	return "projection not found"
}